package com.r0adkll.deckbuilder.arch.data.features.decks.repository

import com.r0adkll.deckbuilder.arch.domain.features.cards.model.Expansion
import com.r0adkll.deckbuilder.arch.domain.features.cards.model.PokemonCard
import com.r0adkll.deckbuilder.arch.domain.features.cards.repository.CardRepository
import com.r0adkll.deckbuilder.arch.domain.features.decks.model.Deck
import com.r0adkll.deckbuilder.arch.domain.features.decks.repository.PTCGOConverter
import io.pokemontcg.model.SuperType
import io.reactivex.Observable
import timber.log.Timber
import java.io.StringReader
import javax.inject.Inject


class DefaultPTCGOConverter @Inject constructor(
        val repository: CardRepository
) : PTCGOConverter {

    override fun import(deckList: String): Observable<List<PokemonCard>> {
        return repository.getExpansions()
                .flatMap {
                    val cards = parsePtcgoDeckList(it, deckList)
                    val ids = cards.map { it.id }
                    repository.searchIds(ids)
                            .map { pokes ->
                                val allCards = ArrayList<PokemonCard>()
                                pokes.forEach { poke ->
                                    val count = cards.find { it.id == poke.id }?.count ?: 0
                                    (0 until count).forEach {
                                        allCards.add(poke.copy())
                                    }
                                }
                                allCards
                            }
                            .doOnNext { Timber.d("Pokemon Found: $it") }
                }
    }

    override fun export(deck: Deck): Observable<String> {
        val pokemon = deck.cards.filter { it.supertype == SuperType.POKEMON }
        val trainers = deck.cards.filter { it.supertype == SuperType.TRAINER }
        val energy = deck.cards.filter { it.supertype == SuperType.ENERGY }

        val listBuilder = StringBuilder()
        listBuilder
                .appendln("****** Pokémon Trading Card Game Deck List ******")
                .appendln()
                .appendln("##Pokémon - ${pokemon.size}")
                .appendln()

        val groupedPokemon = pokemon.groupBy { it.id }
        groupedPokemon.entries.forEach {
            val count = it.value.size
            val poke = it.value.first()
            listBuilder.appendln("* $count ${poke.name} ${poke.expansion!!.ptcgoCode} ${poke.number}")
        }

        listBuilder
                .appendln()
                .appendln("##Trainer Cards - ${trainers.size}")
                .appendln()

        val groupedTrainers = trainers.groupBy { it.id }
        groupedTrainers.entries.forEach {
            val count = it.value.size
            val trainer = it.value.first()
            listBuilder.appendln("* $count ${trainer.name} ${trainer.expansion!!.ptcgoCode} ${trainer.number}")
        }

        listBuilder
                .appendln()
                .appendln("##Energy - ${energy.size}")
                .appendln()

        val groupedEnergy = energy.groupBy { it.id }
        groupedEnergy.forEach {
            val count = it.value.count()
            val ener = it.value.first()
            listBuilder.appendln("* $count ${ener.name} ${ener.expansion!!.ptcgoCode} ${ener.number}")
        }

        listBuilder
                .appendln()
                .appendln("Total Cards - ${deck.cards.size}")
                .appendln()
                .appendln("****** Deck List Generated by Deck Box https://deckbox.r0adkll.com ******")

        return Observable.just(listBuilder.toString())
    }


    private fun parsePtcgoDeckList(expansions: List<Expansion>, deckList: String): List<CardSpec> {
        val reader = StringReader(deckList)
        val lines = reader.readLines()

        val cards = ArrayList<CardSpec>()
        lines.forEach { line ->
            if (line.startsWith("* ")) {
                val count = parseCount(line)
                if (count != null) {
                    val setInfo = parseSetInformation(line)
                    val name = parseName(line)
                    val expansion = expansions.find { it.ptcgoCode == setInfo.first }
                    val id = "${expansion?.code}-${setInfo.second}"
                    cards.add(CardSpec(count, name, setInfo.first, setInfo.second, id))
                }
            }
        }

        return cards
    }


    private fun parseExpectedCount(line: String, prefix: String): Int {
        val remaining = line.replace(prefix, "").replace("-", "").trim()
        return remaining.toIntOrNull() ?: 0
    }


    private fun parseCount(line: String): Int? {
        val countPart = line.substring(2, line.indexOf(" ", 2))
        return countPart.toIntOrNull()
    }


    private fun parseSetInformation(line: String): Pair<String, String> {
        val parts = line.trim().split(" ")
        val number = parts.last()
        val set = parts[parts.size - 2]
        return Pair(set, number)
    }


    private fun parseName(line: String): String {
        val clean = line.substring(2).trim()
        val parts = clean.split(" ").toMutableList()
        val nameParts = parts.dropLast(2)
        return nameParts.joinToString(" ")
    }


    data class CardSpec(
            val count: Int,
            val name: String,
            val set: String,
            val number: String,
            val id: String
    )
}